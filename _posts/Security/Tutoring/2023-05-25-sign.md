---
title: "2023-1 SW Tutoring - 전자서명"
excerpt: "Tutoring Post"

categories:
    - Tutoring
tags:
  - [전자서명, MAC, 암호학적 해쉬함수]

toc: true
toc_sticky: true
 
---
# 전자서명

- 종이 서명 vs 전자 서명

| |종이 서명|전자 서명|
|---|---|---|
작성 형태|문서 내 서명|문서와 서명 분리
검증 방법|문서내 서명과 기존 서명 기록 대조, 비교| 별도의 검증기술 적용
서명과 문서의 관계|1:n|n:n
서명 검증|검증 기관 필요|공개검증 (공인인증서)

- 이론적 전자서명 (해시 사용 X)
$Sign(m)$

### 공개키 암호 알고리즘과 유사한 방식

공개키: 공개키로 암호화하고 개인키로 복호화

전자서명: 개인키로 서명 공개키로 검증

### 문제점?

Alice의 m이 너무 크면 느리다 → 공개키 암호 알고리즘의 특성 때문에 (소수, 지수연산.. 등)

—> m을 hash하고, hash(m)값에 서명

### 암호학적 해쉬함수 후 서명의 장점

1. 큰 파일을 서명할 떄 효율적
2. 서명의 순서 변경이나 삭제 방지
- 순서 변경

메세지 m을 m1, m2로 나눴을 때

이론적:
```
s1 = sign(m1), s2 = sign(m2) vs s1 = sign(m2), s2 = sign(m1)
```
s1, s2를 검증자에게 전송시 m1과 m2의 관계 알지 못함

해시:
```
s1 = sign(hash(m1||m2)) vs s1 = sign(hash(m2||m1))  
-> hash값이 다르기 때문에 다른 서명
```
—> 해시를 이용한다면 m1, m2관계 알 수 있어 순서 변경하면 알아차림

- 삭제

이론적:

s1 = sign(m1), s2 = sign(m2) 생성 후 검증자에게 보낼 때, s2가 사라져도 검증자는 알지 못함

s1과 s2사이의 관계를 모르기때문에!

s1만 도착해도 서명 자체는 통과한다

해시:
```
s1 = sign(hash(m1||m2)) vs s1 = sign(hash(m1))
```

m2 삭제되면 아예 다른 서명값이 나오기 때문에 서명검증 통과 X

—> 해시를 이용한다면 메세지 삭제 여부 알 수 있음

- 그 밖에 전자서명에 대한 위조공격 막기..

### 해시 후 서명
$s=Sign(priv)(h(m))$

## 전자서명이 제공하는 것

1. 무결성
2. 메세지 공개 검증 (개인키로 서명, 공개키로 검증하기 때문에 누구나 검증 가능)
3. 메세지 인증 (공개키로 검증되면 해당 개인키 소유자로부터 온 메세지임을 인증)
4. **부인 방지 (**해당 사인을 생성할 수 있는 사람은 개인키의 소유자이다)

## MAC vs 전자서명

|  | MAC | 전자서명 |
| --- | --- | --- |
| 무결성 | O | O |
| 메세지 인증 | O | O |
| 공개검증 | 대칭키 방식 - 비밀키 공개 불가 | O |
| 키관리 | 키공유이슈 | 개인키/공개키 |
| 부인방지 | X | O |
| 효율성 | 높음 <br>칭키 방식이므로 MAC이 훨씬 빠름 | 낮음 |

## RSA 전자서명

- 이론적(Textbook) RSA 전자서명

랜덤 패딩 없고 메세지 그대로를 암복호화 하는 것

→ 알려진 서명 공격

$s1=m^d(mod p)&s2=n^d(mod p)$
$s1*s2=(m*n)^d(mon p)$
$m^new=m*n$
이라는 새로운 서명 생성 가능

m^new는 공격자가 원하는 값이 아닌 임의의 메세지이지만 개인키 소지자가 생성하지 않은 서명을 생성할 수 있기 때문에 위험


- 이론적 RSA 전자서명 + 해시
해시의 역상저항성 때문에 알려진 서명이라도 공격 불가함

$h(m)*h(n)!=h(m*n)$

## ECDSA 전자서명

DSA 전자서명(미국 표준)을 타원곡선에 적용한 것

모든 데이터 서명해야하는 블록체인 등에 사용

왜?? RSA보다 타원곡선 암호가 빠르고 서명사이즈가 1/10으로 줄어들기 때문에
