---
title: "2023-1 SW Tutoring - Final Test"
excerpt: "Tutoring Post"

categories:
- Tutoring
tags:
- [Security]

toc: true
toc_sticky: true

use_math: true

date: 2023-06-11
last_modified_at: 2023-06-11
---
# 전자서명
## 1. 전자서명이 제공하는 보안 4가지를 말하고 설명하세요
무결성 - 해시  
공개검증 - 개인키로 서명, 공개키로 누구나 검증 가능  
부인방지 - 서명이 A의 공개키로 열리면 해당 메세지는 A가 서명하지 않았다고 부인할 수 없음  
메세지 인증 - 해당 메세지를 서명자가 만든 것임을 인증함
<br>

## 2. MAC과 전자서명의 공통점과 차이점 서술
공통점
1. 무결성과 메세지 인증을 제공한다.   
2. 해시함수를 이용한다.
<br>

차이점  
1. MAC는 대칭키, 전자서명은 공개키 방식으로 전자서명의 속도가 더 느리다.
2. MAC은 부인방지를 제공하지 않는다.
3. MAC은 키 공유 이슈가 존재하지만 전자서명은 아니다.
<br>

## 3. 이론적(Textbook) 전자서명의 단점 두가지를 말하고 해결방안을 예시와 함께 서술하세요 (각 단점을 어떻게 해결했는지..)  
1. 이론적 RSA  
알려진 서명공격에 취약하다. 알려진 서명공격이랑 A가 서명한 s1, s2를 곱하면 A가 서명하지 않았지만 A의 공개키로 검증되는 s3이 나온다. 메세지 값은 랜덤값이겠지만 서명자가 생성하지 않은 서명을 만들 수 있으므로 주의해야 한다.  
해당 방법은 메세지를 해시한 후, 서명하면 해결된다.  
***서명의 순서 변경 + 삭제 방지에도 효과적***
<br>

2. 큰 파일에 서명할 때 효율적이지 못하다.  
전자서명은 공개키 기반으로 큰 용량을 다룰 때 매우 느리다. 파일을 해시한 후 서명하면 해결!

<br>

## 4. 공개키 기반 구조 (PKI)에서 Alice가 Bob을 인증하는 과정을 최대한 자세하게 서술하세요 (Bob의 인증서 발급 절차, Alice가 Bob에게 요청했을 때 과정...)
1. Bob은 개인키와 공개키를 생성하여 CA로부터 인증서를 발급받은 상태다. 
2. Alice는 Bob에게 인증서를 요청한다.
3. Bob은 자신의 공개키와 인증서를 전송한다.
4. Alice는 CA의 공개키로 Bob의 인증서를 검증하여 Bob의 공개키를 인증한다.
5. 인증서의 폐기여부 확인 후, Bob 인증 성공
<br>

## 5. Alice가 은행에 거래를 요청하려 할 때, 인증서를 사용하는 과정  
1. 자신의 비밀키를 통해 개인키를 복호화한다.
2. 복호화한 개인키로 거래(Transition)을 서명한 후, 은행(RA)에게 보낸다. 
3. RA는 Alice의 인증서 발급과정에서 저장한 Alice의 인증서를 CA의 공개키로 접근하여 Alice의 공개키를 얻는다.
4. Alice의 공개키로 서명된 거래를 검증한다.
5. 폐기 여부 확인 후, 거래완료
<br>

# 개체인증
## 1. Message Authentication과 Entity Authentication의 특징 및 예시를 들어 설명
- 메세지 인증  
실시간이 아니어도 되며, 각 메세지마다 수행된다.  
예시로는 이메일로 비밀번호 찾기가 있다.  

- 개체 인증
실시간성이 있으며, 한 번 인증한 후는 일정기간 유지된다는 특성이 있다.  
예시로는 은행 사이트 한 번 로그인하면 일정기간동안 유지..
<br>

## 2. 패스워드 기반 인증에서, 패스워드를 해시할 때 salt를 사용하는 이유와 이로 인해 얻을 수 있는 효과
salt를 사용하는 이유는 패스워드의 dictionary attack에 대응하기 위해서이다. 패스워드를 해쉬하여 저장했더라도 취약한 비밀번호를 사용하고 있다면 dictionary를 pre-computatione하여 비교하면 찾을 수 있기 때문..  

이로 인해 얻을 수 있는 효과는  
1. 취약한 패스워드를 사용하더라도 랜덤값을 더해 저장함으로써 최종 해시는 random string이 되어 dictionay attack에 안전하다.
2. 서버에게 직접 자신의 패스워드를 주지 않고, 서버로부터 salt값을 받아 hash(pwd+salt)의 형태로 제공할 수 있다.

<br>

## 3. Challenge-Response 방식에서 Challenge에 Freshness가 필요한 이유와 Freshness의 종류 
Freshness가 필요한 이유는, A와 B의 통신에서 사용했던 Challenge를 C가 재사용 할 수도 있기 때문이다.  
C가 B에게 해당 challenge를 보내면 B의 입장에서는 A의 challenge로 인식하여 C를 A라고 생각하며 통신을 주고받는다. -> 도청을 통한 공격에 취약하다.  

따라서 Timestamp, 난수를 통핸 Freshness가 challenge에 적용되어야한다. 
<br>

# 키관리 시스템

## 1. KDC 기반 공유 방법에 대해 서술하고, 해당 방법의 장/단점 (단점 - 구조상 발생할 수 있는 공격.. 등)
KDC란 키 분배센터를 의미하며 모든 사용자가 신뢰하는 중앙서버 형식이다.  
사용자와 서버 간 인증이 되어있는 상태에서, Alice가 Bob에게 통신을 요청한다면  
1. Alice는 KDC에게 Bob과의 세션키를 발급 요청한다.
2. KDC는 Bob에게 Alice의 요청 통보 및 Bob의 동의를 얻는다. 
3. KDC는 임의로 생성한 대칭키 $K_{AB}$ 를 각자의 비밀키(대칭키)로 암호화하여 전달한다.
4. Alice와 Bob은 $K_{AB}$ 를 이용하여 통신할 수 있다. 

<br>

## 2. 디피-헬만 동의 프로토콜의 방법에 대해 말하고 안전한 이유 서술
g, p 는 서로 공유된 값이며, 
1. Alice가 Bob에게 $R_1 = g^x mod(p)$ 를 보낸다.
2. Bob은 Alice에게 $R_2 = g^y mod(p)$ 를 보낸다. 

Alice와 Bob은 $g^{xy}$ 라는 비밀키를 사용할 수 있다.  

해당 방법이 안전한 이유는, Eve가 R1과 R2를 알더라도 지수/나머지 연산의 특징때문에 x나 y를 알기 어렵기 때문이다. 
<br>

## 3. 디피-헬만 동의 프로토콜의 한계 및 해결방안
하지만 중간자가 Alice의 R1을 가로채 Alice와 Bob에게 $R_3=g^z mod(p)$ 를 보낸다면 각각 $g^{xz}$ , $g^{zy}$ 로 통신하는 형태가 된다. -> 중간자 공격이 가능하다.  
따라서 R을 해당 사용자가 보낸 것이 맞는지 검증하는 과정이 필요하며, 인증서를 사용하는 STS형태로 해결할 수 있다. 
<br>

# 네트워크 보안 기초 1
## 1. Link Encryption, End-to-End Encryption을 예시를 들어 설명
- 링크  
모든 링크에서 암호화가 수행된 것을 말하며, A와 B가 K서버를 통해 통신할 때, A-K, K-B를 연결하는 모든 링크가 암호화 된 것이다. 

- 종단간
데이터 송/수신자 사이가 전부 암호화 된 것을 말한다. A-B사이의 암호화도 존재한다는 것이다. 
<br>

## 2. SSL/TLS 프로토콜은 무슨 목적으로 사용되며, 어떠한 방식으로 사용하는지 (방식 - Layer사이에서.. HTTP 위에... 이런느낌)  
Application과 Transport 사이에 위치하여 Application data를 암호화하기 위해 사용한다. HTTP + TLS + TCP를 통해 HTTPS를 제공하는 형태이다. 
<br>

## 3. TLS HandShake 과정에 대해 설명 (어떤 정보를 주고받는지, 그 정보를 어떻게/어떤 곳에 사용하는지.. 등)  
- Phase 1  
client-server hello를 하며 TLS 버전 / 암호 알고리즘 / 랜덤값 등을 교환한다.  
암호 알고리즘 교환을 통해 암호화에 사용할 알고리즘을 선택하며, 이때 교환한 랜덤값은 키생성에 사용된다.  
<br>

- Phase 2
Server가 Client에게 인증서와 공개키를 보내 클라이언트가 서버를 인증하게 된다.  
서버 키교환값 ( $g^s$ )를 서명하여 보낸다.   
필요시, 서버는 Client의 인증서를 요청할 수 있다.
<br>

- Phase 3
인증서를 요청받았다면 Client 인증서와 함께 $g^c$ 를 전송한다.
따라서 $g^{sc}$ 라는 Pre-master Key를 공유할 수 있다.

- Phase 4
암호 알고리즘과 보안 파라미터 변경하는 메세지 주고받으며 Handshake END.  
PM으로 키 만들어서 통신에 사용할 수 있다. 

## 4. 최종적으로 TLS는 Application data의 무엇을 보장해주는지 과정과 함께 설명    
클라이언트와 서버 사이에 메세지 인증, 기밀성, 가용성을 제공한다.  
1. Application data를 key를 이용해 hash하여 MAC값을 만들어 메세지 인증을 제공한다.
2. data + MAC값을 암호화하여 Application data의 기밀성을 보장한다.
3. Server-Client 간 교환된 key로 인증/암호화 하였기에 가용성이 존재한다.
<br>

# 네트워크 보안 기초 2
## 1. WEP가 취약한 이유
암호 알고리즘으로 RC4를 사용하였는데, 알고리즘 자체의 취약점으로 WEP도 취약하다. 

<br>

## 2. WPA1 (TKIP), WPA2 (CCMP)의 차이점과 각 특징 한가지씩
- TKIP  
WEP를 지원하기 위해 고안된 모드이기 때문에, 동일한 RC4에 더 강화된 IV를 사용한다.   

- CCMP  
기존의 무선랜 프로토콜과는 전혀 다르게 AES를 적용하여 매우 안전하다. 
<br>

## 3. Enterprise / Personal Mode의 차이점과 각 특징 한가지씩
- Enterprise  
권한 있는 사람만 접근 가능하도록 만들어졌기 때문에, 인증과 키분배를 위한 RADIUS 서버가 필요하다. 

- Personal Mode
인증서버가 필요하지 않으며, PSK라는 비빌번호를 통해 접속한다. 
<br>

# 네트워크 보안 3
## 1. IPSec를 사용하는 이유를 데이터 보호 / 헤더 보호 측면에서 서술  

- Transport 모드에서는 IP 헤더 전까지 모든 데이터에 대한 인증 또는 암호화까지 제공하기 때문에 Application data를 보호하는 데 효과적이다. 

- Tunnel 모드에서는 network 위에 IPSec 사용 후 또 새로운 network layer가 들어가기 때문에 IP 헤더 포함 기존 데이터의 전부가 포함된다.  
해당 방식을 사용하면 트래픽을 숨기 수 있다. 
<br>

## 2. Transport / Tunnel 지원 모드의 작동 방식과 각 모드의 특징 서술  

위와.. 동일
<br>

## 3. AH / ESP 보안 프로토콜의 차이점 두가지  

AH - IP 헤더와 데이터 사이에 위치하여 데이터에 대한 인증을 제공해준다.  
Network Lalyer에서 변하는 값을 제외한 모든 데이터에 대한 인증값을 만들어 AH 헤더에 포함시키는 방식이다.  

ESP - IP 헤더와 데이터 사이에 ESP 헤더가 들어오고, 데이터 끝에 ESP 꼬리가 붙고 인증값이 붙는 형태이다.  
데이터와 Trailer까지 암호화하며 ESP 헤더까지 포함해 인증을 제공한다.

1. AH - 헤더만, ESP - 헤더, 꼬리
2. AH - 인증만, ESP - 인증+암호화 //AH는 보안을 제공하지는 않는다


<br>

## 4. IPSec의 4가지 방법 중 가장 효과적이라고 생각한 것을 고르고 그렇게 생각한 이유를 서술  

Tunnel + ESP 방식이다.  
터널모드를 통해 IP헤더까지 보호할 수 있으며, ESP 보안 프로토콜을 이용하면 인증과 암호화까지 제공하여 IP헤더와 데이터를 더욱 안전하게 지킬 수 있다.  

반면에 Transport + ESP 방식은 IP 헤더가 아닌 Application data에 암호화를 적용시켜주는 방식이다. 이것은 TLS가 적용된 data라면 할 필요가 없어진다..  
(그렇지 않은 데이터라면 효과적이겠지만)
<br>

## 5. TLS와 IPSec를 비교했을 때, 차이점 두가지 서술

TLS는 Application과 Transport 사이에서 동작하는 반면, IPSec는 Transport와 Network에서 동작한다. 

TLS는 Application data만 암호화할 수 있는 반면, IPSec의 일부 모드는  data + IP 헤더까지 보호할 수 있다.  

TLS는 HTTPS라는 일반 통신에 주로 사용되지만, IPSec은 VPN같은 특수 보안통신에 주로 사용된다.
<br>