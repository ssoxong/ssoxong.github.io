---
title: "System Programming - Race and Synchronization"
excerpt: "SP post"

categories:
    - SystemProgramming
tags:
  - [System, Programming, Race, Synchronization, Mutex, Semaphore]

toc: true
toc_sticky: true
 
date: 2023-06-03
last_modified_at: 2023-06-03
---

## Races
경주처처럼 여러 곳에서 접근하여 실행하는 것.

- Race condition
    언제 도착할지 예측하지 못한다.
--> 한번에 하나만 작업 가능하도록 순서대로 동작하도록 동기화 작업 필요

## Synchronization
동기화 작업을 통해 Race Condition 피하기

## Data Races
발생 시점
- 두개 이상의 concurrent flow가 공유 자원에 접근한 경우 
- 하나 이상의 흐름이 상태를 변경하는 경우
- 접근/수정 순서가 중요하다

**data read는 상관 없지만 write가 중요하다**

### Race Example
```c
char* s[4];
int strnum;

void setstring(char *str){
    int index = strnum;
    s[index]=str;
    strnum++;
}
```
thread 접근이 랜덤이기 때문에 strnum이 순차적으로 증가하지 않는다. 
-> s에 덮어써지는 이슈 등 발생..

## Critical Section
공유자원에 영향을 미치는 곳
해당 부분을 정의하여 single thread만 돌도록 한다.

해당 부분이 넓을수록 성능 저하

- shared data에 write하는 대부분의 코드가 critical section...
- 해당 부분이 변경되지 않는다면 read는 critical section아님

## Atomic Operation
하드웨어적으로 접근한다.
가장 단순한 동기화 메카니즘이다.

- cannot be interrupted
- 동시에 실행되지 않는 것처럼 보인다 (sigle-thread만 수행하도록 되어있기에)
- 모두 성공 아니면 모두 실패다 (부분은 없음 atomic: 쪼개질 수 없는, 원자의)


모든 atomic operation은 하드웨어의 서포트가 필요하다.

**모든 기계어가 atomic 한 것은 아니다**

ex) 더하기
- add -> atomic_add

--> c에서는 라이브러리 형태로 사용한다

## Mutex
Mutual Exclusion
atomic operation은 하드웨어의 도움이 필요하기에.. 해당 방법 이용

- 공유 자원에 한번에 하나의 thread만 접근할 수 있도록 한다. (only one logical control flow)
- 상호 배타적이다 - lock을 건 스레드가 ownership을 가진다.

### lock
thread가 mutex에 진입하여 lock걸기
lock 성공하면 return 0


- mutex
    locked 상태
- other thread
    - lock
        locked된 상태에서 다시 lock걸리지 못하기 때문에 계속 lock 시도함
    - trylock
        locked 된 뮤텍스에 lock걸면 안걸림
        -> 자기 자리로 돌아감..
- deadlock
locked된 상태에서 계속 주인 스레드가 lock 걸면 발생

### unlock
locked 된 mutex를 unlock하여 다른 스레드가 lock을 걸 수 있도록 함.

- mutex
    unlocked 상태
- ohter thread
    - lock/trylock
        lock을 걸려고 한 스레드 중 랜덤으로 ownership 가짐
        
        T1이 locked했을 때, T2가 lock 계속 걸고있고, mutex unlock된 상태에서 T3이 lock/trylock 하였어도 T2가 될지 T3이 될지 모름.

        **lock 거는 순서에 따라 정해지는 것이 아니다**
- deadlock
    unlocked된 mutex에 unlock을 걸면 이러한 상황이 발생할 수 있다.

### trylock
mutex에 lock을 한 번 시도하고, 성공시 locked / 실패시 계속 시도하지 않고 호출부로 돌아감
always return immediately

lock 성공하면 return 0

## Using Mutex around Critical Section
- 뮤텍스를 통해 critical section을 보호한다

1. lock mutex
2. critical section 실행
3. unlock mutex
--> critical section에서 하나의 스레드만 돌아감
(only one flow)

**mutex ensure mutual exclusion in the critical section**

## pthread_mutex_t
- pthread_mutex_init()
    뮤텍스 초기화 및 생성
- pthread_mutex_lock(pthread_mutex_t *mutex)
- pthread_mutex_trylock(pthread_mutex_t *mutex)
- pthread_mutex_unlock(pthread_mutex_t *mutex)


