---
title: "System Programming - Virtual Memory"
excerpt: "SP post"

categories:
    - SystemProgramming
tags:
  - [System, Programming, VirtualMemory]

toc: true
toc_sticky: true
 
date: 2023-05-28
last_modified_at: 2023-05-28
---
# Virtual Memory
### System Using Physical Addressing
![image](https://github.com/ssoxong/ssoxong.github.io/assets/112956015/fcdd99ff-8f33-4c92-a5b3-ba4c68c77df8)

1. 메모리 구조가 그대로 올라가기 때문에 보안 취약
2. 여러 시스템이 돌아가면 메모리 관리가 어려움
3. os가 없는 시스템에서 사용하던 옛날 버전

### System using Virtual Addressing
![image](https://github.com/ssoxong/ssoxong.github.io/assets/112956015/e45f58fd-c3ca-441c-af69-84ce32905bb0)

CPU에서 중간단계인 MMU를 거쳐 VA를 PA로 변환하는 가정.
MMU가 실제 메모리에 VA가지고 PA를 맵핑함

##### 장점
1. PA보다 더 크게 VA를 사용할 수 있다. 
2. PA를 고려하지 않아도 된다. 
3. VA - 프로그램이 바라보는 메모리, PA - 실제 메모리를 분리해서 바라볼 수 있는 장점이 존재한다.

#### VM을 사용하는 이유?
1. 메인 메모리를 효율적으로 사용할 수 있다. 
    VA 부분으로 DRAM을 캐시 형태로 사용할 수 있다 (?)
2. 메모리 관리를 단순화할 수 있다.
    linear하여 0번지부터 시작됨
3. 메모리 영역 분할
    다른 프로세스의 메모리에서 또다른 프로세스의 메모리에 참조하지 못함

##### 4. Process Layout
- 각 프로세스의 메모리는 독립적이다.
- 프로세스는 전 주소 공간에 접근할 수 있지만, 서로다른 메모리에서는 접근 거부 (모순적)
--> VM에서는 이런걸 가능하게 한다...

##### 5. Physical Layout
- PM에서 커널 영역 접근 불가
- Device들이 메모리 주소 공간에 나타날 수 있다.
-  System마다 RAM 용양 다를수도..
--> VM을 통해 메모리가 나뉘어져서 MMU가 이상접근 차단하고, 이런 디테일을 숨김.

### Address Spaces
Architecture별 상이
64bit 아키텍처는 48비트만 가능하다
- Linear address space: 0~...
- Virtual address space: 0~n-1
    가장 큰 범위 사용
    sys, platform별 상이
- Physical address space: 0~m-1
    os, architechture별 상이
 
### Address Locations
현재) byte 
과거) word 단위 (한의 주소에 한 워드만..)

### Memory Management Unit (MMU)
##### Address Trnaslation 과정
1. MMU가 주소 해석
2. VA -> PA
3. PA로 physical RAM 접근

## VM as a Tool for Caching
##### Address
- CPU가 VA 이용
- 메인 메모리가 PA 이용  

![image](https://github.com/ssoxong/ssoxong.github.io/assets/112956015/b6f12765-a3e3-4614-8ba9-763ceec8e4ea)  

MMU가 VA를 PA로 바꿀 때 Page map or table 이용
- 모든 VA가 Page map에 있는 것은 아니다.
- 모든 PA가 메인 메모리 (DRAM)에 올라가지 못하기 때문에 일부는 Disk 저장

서로다른 프로세스에서 lib같은 공유자원 이용시 PM에 하나만 올림
    
### DRAM Cache Organization
##### 속도
SRAM > DRAM >> Disk(SSD)
- SRAM
    캐시처럼 작은 용량의 고속 메모리
- DRAM
    싸고 SRAM 보다는 느리지만 용량 큼 / 주로 메인 메모리로 사용
- Disk, SSD
    액세스 속도 느리며 용량 큼

VM 입장에서는 DRAM을 cache로 생각하고 접근

##### 단위
- CPU <-> Cache: word(4byte)
- Main Memory에서 데이터를 주고받는 단위: page(4kb / 4mb)

#### Consequences (결과)
- 큰 page 단위
-  Fully Associative
    어떤 VP라도 PP에 맵핑 가능
    mapping func 필요
- 매우 정교하고, 비싼 교체 알고리즘 (PM <-> Disk)
- Write-back rather than write-through
    - write back
        Physical Memory가 디스크에 내려갈 때만 디스크에 쓴다.
        SRAM에 비해 DRAM의 성능 향상을 위한 방법
        ![image](https://github.com/ssoxong/ssoxong.github.io/assets/112956015/457041fb-51db-420d-a63e-a0ce19e3f086)


    - write through
        은행같은 경우,, 실시간 동기화가 필요하다

### Page Table
![image](https://github.com/ssoxong/ssoxong.github.io/assets/112956015/b6b07dae-a6a5-4e59-89b9-2f21e5eb61fa)

VA를 PA로 변환한 결과를 담고있는 테이블
Page Table:
    PM에 올라와있음 - valid(page hit)
    Disk에 저장되어있음 - unvalid (page fault)

##### page fault handler
disk에 있는 페이지를 올리기 위해 pagetable의 하나를 내려야함. & PM도 수정
-> 내려온 것이 victim
내린 후 다시 올려서 VA에서부터 다시 접근 retry -> page hit

1. page miss -> page fault
2. page fault handler select victim
3. offending instruction restarted

##### key point
- demand paging
    miss난 페이지 DRAM(PM)에 올릴 때까지 기다리기

    요청할때만 / 필요할때만 PM에 올라간다

    - lazy swapper
        메모리 전체를 변경(swap)하지 않고 특정 페이지만 교체한다 (victim <-> page fault page)  

    
    - demand paging과 write-back은 독립적

### 중요
- VM이 비효율적인 것처럼 보이지만 locality로 동작함
- programms tend to access a set of active virtual pages called working set
    working set: 활성화되어있는 VP..
- working set size < main memory size
    성능 좋음 / 메인 메모리에 사용할 VP를 다 올릴 수 있으니까..
- SUM(working set size) > main memory size
    Thrashing (page swap) 많이 일어남
    disk 접근 많아짐

## VM as a Tool for Memory Management
- 각 프로세스는 각 virtual address space를 가지고 있다.
- VA는 linear(0부터 순차적)이지만 PA는 그렇지 않고, VP1이 PA 6, VP2가 PA 2에 매칭될 수도 있음
- 프로세스 간 shared data는 PM에 하나만 저장, 공유자원 (read-only면)
    - shared lib 등 이용시 stack<-> heap 사이 unmapped 영역에 저장된다.
    ![image](https://github.com/ssoxong/ssoxong.github.io/assets/112956015/e065a0b7-1d20-401d-9784-854aea0479ca)

## VM as a Tool for Memory Protection
VP마다 권한 설정 가능
Supervisor, read, write, exec, address 비트 존재한다.
VP가 0~n까지 순서대로 있어도 PP에는 랜덤 할당
-> mmu의 메모리 보호
![image](https://github.com/ssoxong/ssoxong.github.io/assets/112956015/c02403dd-19cb-464f-b5ab-a7623cbea22f)

## Summary...
- Virtual Memory
    - MMU를 이용해 VA를 PA로 변경한다
    - CPU가 실제 PA를 몰라도 VA만보고 프로그램 구동 가능하다

- Page 단위로 데이터 교환 (4kb) -> CPU <-> cache
- VA 주소 배열과 PA주소 배열은 다르다.. linear / random
- page fault시 unmapped 메모리 맵핑하기 (disk에서 PM으로 올리기)
- page table은 MMU가 VA -> PA로 바꾸는 데 활용된다


